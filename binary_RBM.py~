import numpy as np
from numba import jit


class binary_RBM(object):

	def __init__(self,n_visible=None,n_hidden=256,batchSize=256,lr=0.01,L2_decay=None,epoches=1):
		self.n_hidden=n_hidden
		self.n_visible=n_visible
		self.batchSize=batchSize
		self.L2_decay=L2_decay
		self.W=np.random.randn(n_visible,n_hidden)
		self.hbias=np.zeros(n_hidden)
		self.vbias=np.zeros(n_visible)
		self.epoches=epoches
		self.lr=lr

	def fit(self,x):

		N=x.shape[0]
		batches,num_batches=self._batchLists(N)

		num_batches=int(num_batches)
		for t in range(0,self.epoches):

			for i in range(0,num_batches):

				idx=batches[i]
				B=x[idx,:].shape[0]

				p_h=self._sigmoid(np.dot(x[idx,:],self.W)+self.hbias)
				if t==0 and i==0:
					h=p_h>np.random.rand(p_h.shape[0],p_h.shape[1])
				p_v=self._sigmoid(np.dot(h,self.W.T)+self.vbias)
				v=p_v>np.random.rand(p_v.shape[0],p_v.shape[1])

				q_h=self._sigmoid(np.dot(v,self.W)+self.hbias)
				h=q_h>np.random.rand(q_h.shape[0],q_h.shape[1])

				print p_v.shape
				print v.shape
				print q_h.shape
				print h.shape

				W_old=self.W
				h_old=self.hbias
				v_old=self.vbias

				g_W=np.dot(x[idx,:].T,p_h)-np.dot(v.T,q_h)
				g_W/=B
				g_h=x[idx,:].mean(axis=0)-v.mean(axis=0)
				g_v=p_h.mean(axis=0)-q_h.mean(axis=0)

				self.W+=self.lr*g_W
				self.hbias+=self.lr*g_h
				self.vbias+=self.lr*g_v

			print "Epoch %d" % (t+1)
		return None


	def _batchLists(self,N):
		num_batches=np.ceil(N/self.batchSize)
		batch_idx=np.tile(np.arange(0,num_batches)\
				,self.batchSize)
		batch_idx=batch_idx[0:N]
		np.random.shuffle(batch_idx)
		batch_list=[]

		for i in range(0,int(num_batches)):
			idx=np.argwhere(batch_idx==i)
			batch_list.append(idx)

		return batch_list,num_batches
	@jit
	def _sigmoid(self,z):
		return 1/(1+np.exp(-z))



if __name__=="__main__":
	rbm=binary_RBM(784)
	x=np.random.rand(100,784)
	rbm.fit(x,batchSize=10)
